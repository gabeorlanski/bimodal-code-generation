{"source_file": "mbpp.jsonl", "function": "min_cost", "task": "MBPP", "task_id": 1, "description": "Write a function to find the minimum cost path to reach (m, n) from (0, 0) for the given cost matrix cost[][] and a position (m, n) in cost[][].", "code": "def min_cost(cost, m, n): \n\ttc = [[0 for x in range(C)] for x in range(R)] \n\ttc[0][0] = cost[0][0] \n\tfor i in range(1, m+1): \n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \n\tfor j in range(1, n+1): \n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \n\tfor i in range(1, m+1): \n\t\tfor j in range(1, n+1): \n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \n\treturn tc[m][n]", "input_output_pairs": [{"input": "min_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]], 2, 2)", "output": "8", "ops": "=="}, {"input": "min_cost([[2, 3, 4], [5, 9, 3], [2, 6, 4]], 2, 2)", "output": "12", "ops": "=="}, {"input": "min_cost([[3, 4, 5], [6, 10, 4], [3, 7, 5]], 2, 2)", "output": "16", "ops": "=="}], "context": "R = 3\nC = 3", "instance_idx": 0, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "similar_elements", "task": "MBPP", "task_id": 2, "description": "Write a function to find the similar elements from the given two tuple lists.", "code": "def similar_elements(test_tup1, test_tup2):\n  res = tuple(set(test_tup1) & set(test_tup2))\n  return (res)", "input_output_pairs": [{"input": "similar_elements((3, 4, 5, 6), (5, 7, 4, 10))", "output": "(4, 5)", "ops": "=="}, {"input": "similar_elements((1, 2, 3, 4), (5, 4, 3, 7))", "output": "(3, 4)", "ops": "=="}, {"input": "similar_elements((11, 12, 14, 13), (17, 15, 14, 13))", "output": "(13, 14)", "ops": "=="}, {"input": "similar_elements(range(12), range(12, 13))", "output": "()", "ops": "=="}, {"input": "similar_elements('(a+b)[i]*c', '(a+b)ce')", "output": "('+', 'b', 'a', ')', 'c', '(')", "ops": "=="}, {"input": "similar_elements('(abc+)ef{fg}', '(abc+)ef{gf}')", "output": "('e', 'f', '+', 'b', 'a', 'g', ')', 'c', '{', '}', '(')", "ops": "=="}, {"input": "similar_elements((25, 26, 25, 26), (25, 21, 20))", "output": "(25,)", "ops": "=="}, {"input": "similar_elements(tuple((7, 4, 3, 5)), {(1, 4): 2, (2, 4): 5})", "output": "()", "ops": "=="}, {"input": "similar_elements(*((7, 4, 3, 5), (5, 7, 4, 10)))", "output": "(4, 5, 7)", "ops": "=="}, {"input": "similar_elements((27,), (31,))", "output": "()", "ops": "=="}, {"input": "similar_elements((27, 2), (21, 31))", "output": "()", "ops": "=="}, {"input": "similar_elements((22, 31), (26, 32))", "output": "()", "ops": "=="}, {"input": "similar_elements((2.0, 2.1), (32, 22))", "output": "()", "ops": "=="}, {"input": "similar_elements((22.0, 2.1), (32.0, 22.0))", "output": "(22.0,)", "ops": "=="}], "context": "", "instance_idx": 1, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "is_not_prime", "task": "MBPP", "task_id": 3, "description": "Write a python function to identify non-prime numbers.", "code": "def is_not_prime(n):\n    result = False\n    for i in range(2,int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            result = True\n    return result", "input_output_pairs": [{"input": "is_not_prime(2)", "output": "False", "ops": "=="}, {"input": "is_not_prime(10)", "output": "True", "ops": "=="}, {"input": "is_not_prime(35)", "output": "True", "ops": "=="}], "context": "import math", "instance_idx": 2, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "heap_queue_largest", "task": "MBPP", "task_id": 4, "description": "Write a function to find the largest integers from a given list of numbers using heap queue algorithm.", "code": "def heap_queue_largest(nums,n):\n  largest_nums = hq.nlargest(n, nums)\n  return largest_nums", "input_output_pairs": [{"input": "heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 3)", "output": "[85, 75, 65]", "ops": "=="}, {"input": "heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 2)", "output": "[85, 75]", "ops": "=="}, {"input": "heap_queue_largest([25, 35, 22, 85, 14, 65, 75, 22, 58], 5)", "output": "[85, 75, 65, 58, 35]", "ops": "=="}], "context": "import heapq as hq", "instance_idx": 3, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "count_ways", "task": "MBPP", "task_id": 5, "description": "Write a function to find the number of ways to fill it with 2 x 1 dominoes for the given 3 x n board.", "code": "def count_ways(n): \n\tA = [0] * (n + 1) \n\tB = [0] * (n + 1) \n\tA[0] = 1\n\tA[1] = 0\n\tB[0] = 0\n\tB[1] = 1\n\tfor i in range(2, n+1): \n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \n\t\tB[i] = A[i - 1] + B[i - 2] \n\treturn A[n]", "input_output_pairs": [{"input": "count_ways(2)", "output": "3", "ops": "=="}, {"input": "count_ways(8)", "output": "153", "ops": "=="}, {"input": "count_ways(12)", "output": "2131", "ops": "=="}, {"input": "count_ways(22)", "output": "1542841", "ops": "=="}, {"input": "count_ways(11)", "output": "0", "ops": "=="}, {"input": "count_ways(21)", "output": "0", "ops": "=="}, {"input": "count_ways(30)", "output": "299303201", "ops": "=="}, {"input": "count_ways(7)", "output": "0", "ops": "=="}, {"input": "count_ways(8*5)", "output": "216695104121", "ops": "=="}, {"input": "count_ways(9*6+14)", "output": "22035086754287747403", "ops": "=="}, {"input": "count_ways(1*7)", "output": "0", "ops": "=="}], "context": "", "instance_idx": 4, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "differ_At_One_Bit_Pos", "task": "MBPP", "task_id": 6, "description": "Write a python function to check whether the two numbers differ at one bit position only or not.", "code": "def is_Power_Of_Two (x): \n    return x and (not(x & (x - 1))) \ndef differ_At_One_Bit_Pos(a,b): \n    return is_Power_Of_Two(a ^ b)", "input_output_pairs": [{"input": "differ_At_One_Bit_Pos(13, 9)", "output": "True", "ops": "=="}, {"input": "differ_At_One_Bit_Pos(15, 8)", "output": "False", "ops": "=="}, {"input": "differ_At_One_Bit_Pos(2, 4)", "output": "False", "ops": "=="}], "context": "", "instance_idx": 5, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_char_long", "task": "MBPP", "task_id": 7, "description": "Write a function to find all words which are at least 4 characters long in a string by using regex.", "code": "def find_char_long(text):\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))", "input_output_pairs": [{"input": "find_char_long('Please move back to stream')", "output": "['Please', 'move', 'back', 'stream']", "ops": "=="}, {"input": "find_char_long('Jing Eco and Tech')", "output": "['Jing', 'Tech']", "ops": "=="}, {"input": "find_char_long('Jhingai wulu road Zone 3')", "output": "['Jhingai', 'wulu', 'road', 'Zone']", "ops": "=="}, {"input": "find_char_long(u'I am the right burts, July 2011 (August 1900), July 2008 (July 2011) is in the left bults')", "output": "['right', 'burts', 'July', '2011', 'August', '1900', 'July', '2008', 'July', '2011', 'left', 'bults']", "ops": "=="}, {"input": "find_char_long(u'He lie') # This matches the first long", "output": "[]", "ops": "=="}, {"input": "find_char_long('Chasel of Tellie Sheath Warl')", "output": "['Chasel', 'Tellie', 'Sheath', 'Warl']", "ops": "=="}, {"input": "find_char_long(u'He lie')", "output": "[]", "ops": "=="}], "context": "import re", "instance_idx": 6, "test_negations": [], "exclude_tests": ["find_char_long(u'He lie') # This matches the first long ['Please', 'move', 'back', 'stream']", "find_char_long(u'He lie') # This matches the first long ['Jing', 'Tech']", "find_char_long(u'He lie') # This matches the first long ['Jhingai', 'wulu', 'road', 'Zone']", "find_char_long(u'He lie') # This matches the first long ['right', 'burts', 'July', '2011', 'August', '1900', 'July', '2008', 'July', '2011', 'left', 'bults']", "find_char_long(u'He lie') # This matches the first long []", "find_char_long(u'He lie') # This matches the first long ['Chasel', 'Tellie', 'Sheath', 'Warl']"]}
{"source_file": "mbpp.jsonl", "function": "square_nums", "task": "MBPP", "task_id": 8, "description": "Write a function to find squares of individual elements in a list using lambda function.", "code": "def square_nums(nums):\n square_nums = list(map(lambda x: x ** 2, nums))\n return square_nums", "input_output_pairs": [{"input": "square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])", "output": "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]", "ops": "=="}, {"input": "square_nums([10, 20, 30])", "output": "[100, 400, 900]", "ops": "=="}, {"input": "square_nums([12, 15])", "output": "[144, 225]", "ops": "=="}, {"input": "square_nums(range(10))", "output": "[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]", "ops": "=="}, {"input": "square_nums(list(square_nums([1, 2, 3])))", "output": "[1, 16, 81]", "ops": "=="}, {"input": "square_nums([0, 0])", "output": "[0, 0]", "ops": "=="}, {"input": "square_nums((1, 2, 3, 4, 5, 6, 7, 8))", "output": "[1, 4, 9, 16, 25, 36, 49, 64]", "ops": "=="}, {"input": "square_nums((10, 2))", "output": "[100, 4]", "ops": "=="}, {"input": "square_nums([1, 2, 3, 4, 5, 6, 7, 8])", "output": "[1, 4, 9, 16, 25, 36, 49, 64]", "ops": "=="}, {"input": "square_nums(range(-10, 10))", "output": "[100, 81, 64, 49, 36, 25, 16, 9, 4, 1, 0, 1, 4, 9, 16, 25, 36, 49, 64, 81]", "ops": "=="}], "context": "", "instance_idx": 7, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_Rotations", "task": "MBPP", "task_id": 9, "description": "Write a python function to find the minimum number of rotations required to get the same string.", "code": "def find_Rotations(str): \n    tmp = str + str\n    n = len(str) \n    for i in range(1,n + 1): \n        substring = tmp[i: i+n] \n        if (str == substring): \n            return i \n    return n", "input_output_pairs": [{"input": "find_Rotations('aaaa')", "output": "1", "ops": "=="}, {"input": "find_Rotations('ab')", "output": "2", "ops": "=="}, {"input": "find_Rotations('abc')", "output": "3", "ops": "=="}, {"input": "find_Rotations(u'dfff')", "output": "4", "ops": "=="}, {"input": "find_Rotations('abcdefg')", "output": "7", "ops": "=="}, {"input": "find_Rotations('ABCDEFg')", "output": "7", "ops": "=="}, {"input": "find_Rotations(u'0123efg')", "output": "7", "ops": "=="}], "context": "", "instance_idx": 8, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "small_nnum", "task": "MBPP", "task_id": 10, "description": "Write a function to get the n smallest items from a dataset.", "code": "def small_nnum(list1,n):\n  smallest=heapq.nsmallest(n,list1)\n  return smallest", "input_output_pairs": [{"input": "small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 2)", "output": "[10, 20]", "ops": "=="}, {"input": "small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 5)", "output": "[10, 20, 20, 40, 50]", "ops": "=="}, {"input": "small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100], 3)", "output": "[10, 20, 20]", "ops": "=="}], "context": "import heapq", "instance_idx": 9, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "remove_Occ", "task": "MBPP", "task_id": 11, "description": "Write a python function to remove first and last occurrence of a given character from the string.", "code": "def remove_Occ(s,ch): \n    for i in range(len(s)): \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    for i in range(len(s) - 1,-1,-1):  \n        if (s[i] == ch): \n            s = s[0 : i] + s[i + 1:] \n            break\n    return s", "input_output_pairs": [{"input": "remove_Occ('hello', 'l')", "output": "'heo'", "ops": "=="}, {"input": "remove_Occ('abcda', 'a')", "output": "'bcd'", "ops": "=="}, {"input": "remove_Occ('PHP', 'P')", "output": "'H'", "ops": "=="}, {"input": "remove_Occ('hellolloll', 'l')", "output": "'helollol'", "ops": "=="}, {"input": "remove_Occ('', 'l')", "output": "''", "ops": "=="}, {"input": "remove_Occ(r'\\$hello', 'l')", "output": "'\\\\$heo'", "ops": "=="}, {"input": "remove_Occ(r'\\$abcda', 'a')", "output": "'\\\\$bcd'", "ops": "=="}, {"input": "remove_Occ(r'\\$\\\\sdf', 'w')", "output": "'\\\\$\\\\\\\\sdf'", "ops": "=="}, {"input": "remove_Occ(r'\\$PHP \\\\sdf', 'a')", "output": "'\\\\$PHP \\\\\\\\sdf'", "ops": "=="}, {"input": "remove_Occ(r'\\${ralph \\$\\\\s\\}', 'd')", "output": "'\\\\${ralph \\\\$\\\\\\\\s\\\\}'", "ops": "=="}, {"input": "remove_Occ('\\$HELLO\\${ralph \\$\\\\s\\}', 'd')", "output": "'\\\\$HELLO\\\\${ralph \\\\$\\\\s\\\\}'", "ops": "=="}, {"input": "remove_Occ('H', 'h')", "output": "'H'", "ops": "=="}, {"input": "remove_Occ('\\$\\[1\\\\\\]', 'l')", "output": "'\\\\$\\\\[1\\\\\\\\]'", "ops": "=="}, {"input": "remove_Occ(r'\\$\\(l\\)', 'l')", "output": "'\\\\$\\\\(\\\\)'", "ops": "=="}, {"input": "remove_Occ('\\$\\[2\\\\\\]', 'n')", "output": "'\\\\$\\\\[2\\\\\\\\]'", "ops": "=="}, {"input": "remove_Occ('wizza', 'a')", "output": "'wizz'", "ops": "=="}, {"input": "remove_Occ('', 'r')", "output": "''", "ops": "=="}], "context": "", "instance_idx": 10, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "sort_matrix", "task": "MBPP", "task_id": 12, "description": "Write a function to sort a given matrix in ascending order according to the sum of its rows.", "code": "def sort_matrix(M):\n    result = sorted(M, key=sum)\n    return result", "input_output_pairs": [{"input": "sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1]])", "output": "[[1, 1, 1], [1, 2, 3], [2, 4, 5]]", "ops": "=="}, {"input": "sort_matrix([[1, 2, 3], [-2, 4, -5], [1, -1, 1]])", "output": "[[-2, 4, -5], [1, -1, 1], [1, 2, 3]]", "ops": "=="}, {"input": "sort_matrix([[5, 8, 9], [6, 4, 3], [2, 1, 4]])", "output": "[[2, 1, 4], [6, 4, 3], [5, 8, 9]]", "ops": "=="}, {"input": "list(map(list, sort_matrix([[1], [-1, -2], [7]])))", "output": "[[-1, -2], [1], [7]]", "ops": "=="}, {"input": "list(map(list, sort_matrix([[2, 1, 0], [3, 4, 5], [-1, 2, 7]])))", "output": "[[2, 1, 0], [-1, 2, 7], [3, 4, 5]]", "ops": "=="}, {"input": "sort_matrix([[5, 6, 9], [7, 5, 2]])", "output": "[[7, 5, 2], [5, 6, 9]]", "ops": "=="}, {"input": "sort_matrix([[5, 2, 3], [7, 7, 1]])", "output": "[[5, 2, 3], [7, 7, 1]]", "ops": "=="}, {"input": "sort_matrix([[5, 8, 9], [6, 4, 3], [2, 2, 4]])", "output": "[[2, 2, 4], [6, 4, 3], [5, 8, 9]]", "ops": "=="}, {"input": "sort_matrix([[6, 4, 3], [2, 2, 4]])", "output": "[[2, 2, 4], [6, 4, 3]]", "ops": "=="}, {"input": "sort_matrix(sort_matrix([[4, 4, 1], [4, 4, 0]]))", "output": "[[4, 4, 0], [4, 4, 1]]", "ops": "=="}], "context": "", "instance_idx": 11, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "count_common", "task": "MBPP", "task_id": 13, "description": "Write a function to count the most common words in a dictionary.", "code": "def count_common(words):\n  word_counts = Counter(words)\n  top_four = word_counts.most_common(4)\n  return (top_four)", "input_output_pairs": [{"input": "count_common(['red', 'green', 'black', 'pink', 'black', 'white', 'black',\n    'eyes', 'white', 'black', 'orange', 'pink', 'pink', 'red', 'red',\n    'white', 'orange', 'white', 'black', 'pink', 'green', 'green', 'pink',\n    'green', 'pink', 'white', 'orange', 'orange', 'red'])", "output": "[('pink', 6), ('black', 5), ('white', 5), ('red', 4)]", "ops": "=="}, {"input": "count_common(['one', 'two', 'three', 'four', 'five', 'one', 'two', 'one',\n    'three', 'one'])", "output": "[('one', 4), ('two', 2), ('three', 2), ('four', 1)]", "ops": "=="}, {"input": "count_common(['Facebook', 'Apple', 'Amazon', 'Netflix', 'Google', 'Apple',\n    'Netflix', 'Amazon'])", "output": "[('Apple', 2), ('Amazon', 2), ('Netflix', 2), ('Facebook', 1)]", "ops": "=="}], "context": "from collections import Counter", "instance_idx": 12, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_Volume", "task": "MBPP", "task_id": 14, "description": "Write a python function to find the volume of a triangular prism.", "code": "def find_Volume(l,b,h) : \n    return ((l * b * h) / 2)", "input_output_pairs": [{"input": "find_Volume(10, 8, 6)", "output": "240", "ops": "=="}, {"input": "find_Volume(3, 2, 2)", "output": "6", "ops": "=="}, {"input": "find_Volume(1, 2, 1)", "output": "1", "ops": "=="}, {"input": "find_Volume(7, 1, 1)", "output": "3.5", "ops": "=="}, {"input": "find_Volume(1, 5, 5)", "output": "12.5", "ops": "=="}, {"input": "find_Volume(1, 8, 5)", "output": "20.0", "ops": "=="}, {"input": "find_Volume(1, -1, 2)", "output": "-1.0", "ops": "=="}, {"input": "find_Volume(12, 5, 3)", "output": "90.0", "ops": "=="}, {"input": "find_Volume(6, 1, 1)", "output": "3.0", "ops": "=="}, {"input": "find_Volume(9, 5, 3)", "output": "67.5", "ops": "=="}, {"input": "find_Volume(-1, 3, 3)", "output": "-4.5", "ops": "=="}, {"input": "find_Volume(-3, 3, 3)", "output": "-13.5", "ops": "=="}], "context": "", "instance_idx": 13, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "split_lowerstring", "task": "MBPP", "task_id": 15, "description": "Write a function to split a string at lowercase letters.", "code": "def split_lowerstring(text):\n return (re.findall('[a-z][^a-z]*', text))", "input_output_pairs": [{"input": "split_lowerstring('AbCd')", "output": "['bC', 'd']", "ops": "=="}, {"input": "split_lowerstring('Python')", "output": "['y', 't', 'h', 'o', 'n']", "ops": "=="}, {"input": "split_lowerstring('Programming')", "output": "['r', 'o', 'g', 'r', 'a', 'm', 'm', 'i', 'n', 'g']", "ops": "=="}, {"input": "split_lowerstring(u'C:\\\\Python\\\\')", "output": "['y', 't', 'h', 'o', 'n\\\\']", "ops": "=="}, {"input": "split_lowerstring( 'Python' )", "output": "['y', 't', 'h', 'o', 'n']", "ops": "=="}, {"input": "split_lowerstring('\\n')", "output": "[]", "ops": "=="}, {"input": "split_lowerstring('\\t')", "output": "[]", "ops": "=="}, {"input": "split_lowerstring(r'\\w+\\s')", "output": "['w+\\\\', 's']", "ops": "=="}, {"input": "split_lowerstring(u'\u27a2\u2920\u2918\u2641\u200d\u2701\u2752\u27a4')", "output": "[]", "ops": "=="}], "context": "import re", "instance_idx": 14, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "text_lowercase_underscore", "task": "MBPP", "task_id": 16, "description": "Write a function to find sequences of lowercase letters joined with an underscore.", "code": "def text_lowercase_underscore(text):\n        patterns = '^[a-z]+_[a-z]+$'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return('Not matched!')", "input_output_pairs": [{"input": "text_lowercase_underscore('aab_cbbbc')", "output": "'Found a match!'", "ops": "=="}, {"input": "text_lowercase_underscore('aab_Abbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore('Aaab_abbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore('aab-cbbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore(u'.B.C')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore(u'abc_')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore(u'.B.')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore('.')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore('ab ab-a-')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore( 'abbb-cabbc_aaba' )", "output": "'Not matched!'", "ops": "=="}, {"input": "text_lowercase_underscore('Abc')", "output": "'Not matched!'", "ops": "=="}], "context": "import re", "instance_idx": 15, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "square_perimeter", "task": "MBPP", "task_id": 17, "description": "Write a function to find the perimeter of a square.", "code": "def square_perimeter(a):\n  perimeter=4*a\n  return perimeter", "input_output_pairs": [{"input": "square_perimeter(10)", "output": "40", "ops": "=="}, {"input": "square_perimeter(5)", "output": "20", "ops": "=="}, {"input": "square_perimeter(4)", "output": "16", "ops": "=="}, {"input": "square_perimeter(3)", "output": "12", "ops": "=="}, {"input": "square_perimeter(7)", "output": "28", "ops": "=="}, {"input": "square_perimeter(1)", "output": "4", "ops": "=="}, {"input": "square_perimeter(5.2)", "output": "20.8", "ops": "=="}, {"input": "square_perimeter(11)", "output": "44", "ops": "=="}, {"input": "square_perimeter(9)", "output": "36", "ops": "=="}, {"input": "square_perimeter(3.2)", "output": "12.8", "ops": "=="}, {"input": "square_perimeter(7.5)", "output": "30.0", "ops": "=="}, {"input": "square_perimeter(2.141592653590289384191882)", "output": "8.566370614361157", "ops": "=="}, {"input": "square_perimeter(7)", "output": "28", "ops": "=="}, {"input": "square_perimeter(8)", "output": "32", "ops": "=="}, {"input": "square_perimeter(9)", "output": "36", "ops": "=="}, {"input": "square_perimeter(7)", "output": "28", "ops": "=="}, {"input": "square_perimeter(9)", "output": "36", "ops": "=="}, {"input": "square_perimeter(7)", "output": "28", "ops": "=="}, {"input": "square_perimeter(11)", "output": "44", "ops": "=="}, {"input": "square_perimeter(13)", "output": "52", "ops": "=="}, {"input": "square_perimeter(22)", "output": "88", "ops": "=="}, {"input": "square_perimeter(31)", "output": "124", "ops": "=="}], "context": "", "instance_idx": 16, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "remove_dirty_chars", "task": "MBPP", "task_id": 18, "description": "Write a function to remove characters from the first string which are present in the second string.", "code": "def str_to_list(string): \n\ttemp = [] \n\tfor x in string: \n\t\ttemp.append(x) \n\treturn temp \ndef lst_to_string(List): \n\treturn ''.join(List) \ndef get_char_count_array(string): \n\tcount = [0] * NO_OF_CHARS \n\tfor i in string: \n\t\tcount[ord(i)] += 1\n\treturn count \ndef remove_dirty_chars(string, second_string): \n\tcount = get_char_count_array(second_string) \n\tip_ind = 0\n\tres_ind = 0\n\ttemp = '' \n\tstr_list = str_to_list(string) \n\twhile ip_ind != len(str_list): \n\t\ttemp = str_list[ip_ind] \n\t\tif count[ord(temp)] == 0: \n\t\t\tstr_list[res_ind] = str_list[ip_ind] \n\t\t\tres_ind += 1\n\t\tip_ind+=1\n\treturn lst_to_string(str_list[0:res_ind])", "input_output_pairs": [{"input": "remove_dirty_chars('probasscurve', 'pros')", "output": "'bacuve'", "ops": "=="}, {"input": "remove_dirty_chars('digitalindia', 'talent')", "output": "'digiidi'", "ops": "=="}, {"input": "remove_dirty_chars('exoticmiles', 'toxic')", "output": "'emles'", "ops": "=="}], "context": "NO_OF_CHARS = 256", "instance_idx": 17, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "test_duplicate", "task": "MBPP", "task_id": 19, "description": "Write a function to find whether a given array of integers contains any duplicate element.", "code": "def test_duplicate(arraynums):\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)", "input_output_pairs": [{"input": "test_duplicate([1, 2, 3, 4, 5])", "output": "False", "ops": "=="}, {"input": "test_duplicate([1, 2, 3, 4, 4])", "output": "True", "ops": "=="}, {"input": "test_duplicate([1, 1, 2, 2, 3, 3, 4, 4, 5])", "output": "True", "ops": "=="}, {"input": "test_duplicate(set([1, 2, 3, 4, 4, 5]))", "output": "False", "ops": "=="}, {"input": "test_duplicate([1, 2, 3, 4, 4, 4, 5])", "output": "True", "ops": "=="}, {"input": "test_duplicate(frozenset([1, 2, 3, 4, 4, 5]))", "output": "False", "ops": "=="}, {"input": "test_duplicate(range(5))", "output": "False", "ops": "=="}, {"input": "test_duplicate(list(range(5)))", "output": "False", "ops": "=="}, {"input": "test_duplicate(tuple(range(5)))", "output": "False", "ops": "=="}, {"input": "test_duplicate(range(100000))", "output": "False", "ops": "=="}], "context": "", "instance_idx": 18, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "is_woodall", "task": "MBPP", "task_id": 20, "description": "Write a function to check if the given number is woodball or not.", "code": "def is_woodall(x): \n\tif (x % 2 == 0): \n\t\treturn False\n\tif (x == 1): \n\t\treturn True\n\tx = x + 1 \n\tp = 0\n\twhile (x % 2 == 0): \n\t\tx = x/2\n\t\tp = p + 1\n\t\tif (p == x): \n\t\t\treturn True\n\treturn False", "input_output_pairs": [{"input": "is_woodall(383)", "output": "True", "ops": "=="}, {"input": "is_woodall(254)", "output": "False", "ops": "=="}, {"input": "is_woodall(200)", "output": "False", "ops": "=="}, {"input": "is_woodall(32212254719)", "output": "True", "ops": "=="}, {"input": "is_woodall(32212254718)", "output": "False", "ops": "=="}, {"input": "is_woodall(159)", "output": "True", "ops": "=="}, {"input": "is_woodall(1513379618)", "output": "False", "ops": "=="}, {"input": "is_woodall(7)", "output": "True", "ops": "=="}, {"input": "is_woodall(3686693529)", "output": "False", "ops": "=="}, {"input": "is_woodall(33663399)", "output": "False", "ops": "=="}, {"input": "is_woodall(4)", "output": "False", "ops": "=="}, {"input": "is_woodall(9131114131624)", "output": "False", "ops": "=="}, {"input": "is_woodall(199)", "output": "False", "ops": "=="}, {"input": "is_woodall(19)", "output": "False", "ops": "=="}, {"input": "is_woodall(231546)", "output": "False", "ops": "=="}, {"input": "is_woodall(2325)", "output": "False", "ops": "=="}, {"input": "is_woodall(15495544)", "output": "False", "ops": "=="}, {"input": "is_woodall(0)", "output": "False", "ops": "=="}, {"input": "is_woodall(12233445664)", "output": "False", "ops": "=="}, {"input": "is_woodall(3114351242196874)", "output": "False", "ops": "=="}], "context": "", "instance_idx": 19, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "multiples_of_num", "task": "MBPP", "task_id": 21, "description": "Write a function to find m number of multiples of n.", "code": "def multiples_of_num(m,n): \n    multiples_of_num= list(range(n,(m+1)*n, n)) \n    return list(multiples_of_num)", "input_output_pairs": [{"input": "multiples_of_num(4, 3)", "output": "[3, 6, 9, 12]", "ops": "=="}, {"input": "multiples_of_num(2, 5)", "output": "[5, 10]", "ops": "=="}, {"input": "multiples_of_num(9, 2)", "output": "[2, 4, 6, 8, 10, 12, 14, 16, 18]", "ops": "=="}, {"input": "multiples_of_num(13, 2)", "output": "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26]", "ops": "=="}, {"input": "multiples_of_num(8, 1)", "output": "[1, 2, 3, 4, 5, 6, 7, 8]", "ops": "=="}, {"input": "multiples_of_num(10, 1)", "output": "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]", "ops": "=="}, {"input": "multiples_of_num(1, 3)", "output": "[3]", "ops": "=="}, {"input": "multiples_of_num(0, 4)", "output": "[]", "ops": "=="}, {"input": "multiples_of_num(7, 1)", "output": "[1, 2, 3, 4, 5, 6, 7]", "ops": "=="}, {"input": "multiples_of_num(4, 2)", "output": "[2, 4, 6, 8]", "ops": "=="}, {"input": "multiples_of_num(5, 16)", "output": "[16, 32, 48, 64, 80]", "ops": "=="}, {"input": "multiples_of_num(False, 2)", "output": "[]", "ops": "=="}, {"input": "multiples_of_num(False, 16)", "output": "[]", "ops": "=="}, {"input": "multiples_of_num(42, 4)", "output": "[4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 148, 152, 156, 160, 164, 168]", "ops": "=="}, {"input": "multiples_of_num(5, 3)", "output": "[3, 6, 9, 12, 15]", "ops": "=="}, {"input": "multiples_of_num(16, 2)", "output": "[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32]", "ops": "=="}], "context": "", "instance_idx": 20, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_first_duplicate", "task": "MBPP", "task_id": 22, "description": "Write a function to find the first duplicate element in a given array of integers.", "code": "def find_first_duplicate(nums):\n    num_set = set()\n    no_duplicate = -1\n\n    for i in range(len(nums)):\n\n        if nums[i] in num_set:\n            return nums[i]\n        else:\n            num_set.add(nums[i])\n\n    return no_duplicate", "input_output_pairs": [{"input": "find_first_duplicate([1, 2, 3, 4, 4, 5])", "output": "4", "ops": "=="}, {"input": "find_first_duplicate([1, 2, 3, 4])", "output": "-1", "ops": "=="}, {"input": "find_first_duplicate([1, 1, 2, 3, 3, 2, 2])", "output": "1", "ops": "=="}, {"input": "find_first_duplicate([1, 2, 3, 4, 5, 0, 0, 1])", "output": "0", "ops": "=="}, {"input": "find_first_duplicate(range(1, 10))", "output": "-1", "ops": "=="}], "context": "", "instance_idx": 21, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "maximum_Sum", "task": "MBPP", "task_id": 23, "description": "Write a python function to find the maximum sum of elements of list in a list of lists.", "code": "def maximum_Sum(list1): \n    maxi = -100000\n    for x in list1: \n        sum = 0 \n        for y in x: \n            sum+= y      \n        maxi = max(sum,maxi)     \n    return maxi", "input_output_pairs": [{"input": "maximum_Sum([[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]])", "output": "33", "ops": "=="}, {"input": "maximum_Sum([[0, 1, 1], [1, 1, 2], [3, 2, 1]])", "output": "6", "ops": "=="}, {"input": "maximum_Sum([[0, 1, 3], [1, 2, 1], [9, 8, 2], [0, 1, 0], [6, 4, 8]])", "output": "19", "ops": "=="}, {"input": "maximum_Sum([[0, -1, -1], [-1, -1, -2], [-3, -2, -1]])", "output": "-2", "ops": "=="}, {"input": "maximum_Sum([])", "output": "-100000", "ops": "=="}, {"input": "maximum_Sum([[0, 1, 1], [1, 0, 2], [8, 7, 3], [6, 9, 5]])", "output": "20", "ops": "=="}, {"input": "maximum_Sum([[0, 1, 3], [1, 0, 2], [1, 1, 0]])", "output": "4", "ops": "=="}], "context": "", "instance_idx": 22, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "binary_to_decimal", "task": "MBPP", "task_id": 24, "description": "Write a function to convert the given binary number to its decimal equivalent.", "code": "def binary_to_decimal(binary): \n    binary1 = binary \n    decimal, i, n = 0, 0, 0\n    while(binary != 0): \n        dec = binary % 10\n        decimal = decimal + dec * pow(2, i) \n        binary = binary//10\n        i += 1\n    return (decimal)", "input_output_pairs": [{"input": "binary_to_decimal(100)", "output": "4", "ops": "=="}, {"input": "binary_to_decimal(1011)", "output": "11", "ops": "=="}, {"input": "binary_to_decimal(1101101)", "output": "109", "ops": "=="}, {"input": "binary_to_decimal(100011)", "output": "35", "ops": "=="}, {"input": "binary_to_decimal(100010001)", "output": "273", "ops": "=="}, {"input": "binary_to_decimal(10)", "output": "2", "ops": "=="}, {"input": "binary_to_decimal(100000001)", "output": "257", "ops": "=="}, {"input": "binary_to_decimal(1042)", "output": "18", "ops": "=="}], "context": "", "instance_idx": 23, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_Product", "task": "MBPP", "task_id": 25, "description": "Write a python function to find the product of non-repeated elements in a given array.", "code": "def find_Product(arr,n): \n    arr.sort() \n    prod = 1\n    for i in range(0,n,1): \n        if (arr[i - 1] != arr[i]): \n            prod = prod * arr[i] \n    return prod;", "input_output_pairs": [{"input": "find_Product([1, 1, 2, 3], 4)", "output": "6", "ops": "=="}, {"input": "find_Product([1, 2, 3, 1, 1], 5)", "output": "6", "ops": "=="}, {"input": "find_Product([1, 1, 4, 5, 6], 5)", "output": "120", "ops": "=="}, {"input": "find_Product([1, 1, 4, 5, 6, 5, 7, 1, 1, 3, 4], 11)", "output": "2520", "ops": "=="}, {"input": "find_Product([1, 2, 2, 4, 6, 8, 5, 1, 2, 3, 9], 2)", "output": "1", "ops": "=="}, {"input": "find_Product([1, 7, 4, 6, 10, 10, 10, 1, 1, 9, 6, 11], 11)", "output": "15120", "ops": "=="}], "context": "", "instance_idx": 24, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "check_k_elements", "task": "MBPP", "task_id": 26, "description": "Write a function to check if the given tuple list has all k elements.", "code": "def check_k_elements(test_list, K):\n  res = True\n  for tup in test_list:\n    for ele in tup:\n      if ele != K:\n        res = False\n  return (res)", "input_output_pairs": [{"input": "check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4,)], 4)", "output": "True", "ops": "=="}, {"input": "check_k_elements([(7, 7, 7), (7, 7)], 7)", "output": "True", "ops": "=="}, {"input": "check_k_elements([(9, 9), (9, 9, 9, 9)], 7)", "output": "False", "ops": "=="}, {"input": "check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 6, 4), (4,)], 4)", "output": "False", "ops": "=="}, {"input": "check_k_elements([(7, 7), (7, 7)], 7)", "output": "True", "ops": "=="}, {"input": "check_k_elements([[1, 2], [3, 4]], 4)", "output": "False", "ops": "=="}, {"input": "check_k_elements([[8, 9], [6, 8]], 4)", "output": "False", "ops": "=="}, {"input": "check_k_elements([[7, 9], [8, 9], [8, 9, 8], [3]], 4)", "output": "False", "ops": "=="}], "context": "", "instance_idx": 25, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "remove", "task": "MBPP", "task_id": 27, "description": "Write a python function to remove all digits from a list of strings.", "code": "def remove(list): \n    pattern = '[0-9]'\n    list = [re.sub(pattern, '', i) for i in list] \n    return list", "input_output_pairs": [{"input": "remove(['4words', '3letters', '4digits'])", "output": "['words', 'letters', 'digits']", "ops": "=="}, {"input": "remove(['28Jan', '12Jan', '11Jan'])", "output": "['Jan', 'Jan', 'Jan']", "ops": "=="}, {"input": "remove(['wonder1', 'wonder2', 'wonder3'])", "output": "['wonder', 'wonder', 'wonder']", "ops": "=="}, {"input": "remove(['fantasy', '4words'])", "output": "['fantasy', 'words']", "ops": "=="}, {"input": "remove(['a', 'x', '3a', 'z', 'y'])", "output": "['a', 'x', 'a', 'z', 'y']", "ops": "=="}, {"input": "remove(['a', 'b', 'e'])", "output": "['a', 'b', 'e']", "ops": "=="}, {"input": "remove('1ej')", "output": "['', 'e', 'j']", "ops": "=="}, {"input": "remove('14days')", "output": "['', '', 'd', 'a', 'y', 's']", "ops": "=="}, {"input": "remove(['1', '6'])", "output": "['', '']", "ops": "=="}, {"input": "remove('1d')", "output": "['', 'd']", "ops": "=="}, {"input": "remove(['15', '20', '21', '2', '30', '1s', '1i', '2'])", "output": "['', '', '', '', '', 's', 'i', '']", "ops": "=="}], "context": "import re", "instance_idx": 26, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "binomial_Coeff", "task": "MBPP", "task_id": 28, "description": "Write a python function to find binomial co-efficient.", "code": "def binomial_Coeff(n,k): \n    if k > n : \n       return 0\n    if k==0 or k ==n : \n        return 1 \n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k)", "input_output_pairs": [{"input": "binomial_Coeff(5, 2)", "output": "10", "ops": "=="}, {"input": "binomial_Coeff(4, 3)", "output": "4", "ops": "=="}, {"input": "binomial_Coeff(3, 2)", "output": "3", "ops": "=="}, {"input": "binomial_Coeff(14, 6)", "output": "3003", "ops": "=="}, {"input": "binomial_Coeff(11, 12)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(13, 22)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(27, 36)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(35, 37)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(7, 22)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(29, 35)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(36, 45)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(37, 40)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(29, 37)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(29, 44)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(28, 45)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(29, 39)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(1, 3)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(3, 4)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(13, 23)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(6.6, 17.0)", "output": "0", "ops": "=="}, {"input": "binomial_Coeff(4, 14)", "output": "0", "ops": "=="}], "context": "", "instance_idx": 27, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "get_Odd_Occurrence", "task": "MBPP", "task_id": 29, "description": "Write a python function to find the element occurring odd number of times.", "code": "def get_Odd_Occurrence(arr,arr_size):   \n    for i in range(0,arr_size): \n        count = 0\n        for j in range(0,arr_size): \n            if arr[i] == arr[j]: \n                count+=1     \n        if (count % 2 != 0): \n            return arr[i]     \n    return -1", "input_output_pairs": [{"input": "get_Odd_Occurrence([1, 2, 3, 1, 2, 3, 1], 7)", "output": "1", "ops": "=="}, {"input": "get_Odd_Occurrence([1, 2, 3, 2, 3, 1, 3], 7)", "output": "3", "ops": "=="}, {"input": "get_Odd_Occurrence([2, 3, 5, 4, 5, 2, 4, 3, 5, 2, 4, 4, 2], 13)", "output": "5", "ops": "=="}, {"input": "get_Odd_Occurrence(range(8), 3) == [4, 2, 2]", "output": "False", "ops": "=="}, {"input": "get_Odd_Occurrence(range(9), 3)", "output": "0", "ops": "=="}, {"input": "get_Odd_Occurrence([1, 2, 3, 2, 3, 1, 3, 5, 5, 5, 4], 8)", "output": "3", "ops": "=="}], "context": "", "instance_idx": 28, "test_negations": ["get_Odd_Occurrence(range(8), 3) == [4, 2, 2] False", "get_Odd_Occurrence(range(9), 3) False"], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "count_Substring_With_Equal_Ends", "task": "MBPP", "task_id": 30, "description": "Write a python function to count all the substrings starting and ending with same characters.", "code": "def check_Equality(s): \n    return (ord(s[0]) == ord(s[len(s) - 1])); \ndef count_Substring_With_Equal_Ends(s): \n    result = 0; \n    n = len(s); \n    for i in range(n): \n        for j in range(1,n-i+1):  \n            if (check_Equality(s[i:i+j])): \n                result+=1; \n    return result;", "input_output_pairs": [{"input": "count_Substring_With_Equal_Ends('abc')", "output": "3", "ops": "=="}, {"input": "count_Substring_With_Equal_Ends('abcda')", "output": "6", "ops": "=="}, {"input": "count_Substring_With_Equal_Ends('ab')", "output": "2", "ops": "=="}], "context": "", "instance_idx": 29, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "func", "task": "MBPP", "task_id": 31, "description": "Write a function to find the top k integers that occur most frequently from given lists of sorted and distinct integers using heap queue algorithm.", "code": "def func(nums, k):\n    import collections\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n    temp = []\n    import heapq\n    for key, v in d.items():\n        if len(temp) < k:\n            temp.append((v, key))\n            if len(temp) == k:\n                heapq.heapify(temp)\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n    return result", "input_output_pairs": [{"input": "func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1,\n    4, 7, 8, 12]], 3)", "output": "[5, 7, 1]", "ops": "=="}, {"input": "func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1,\n    4, 7, 8, 12]], 1)", "output": "[1]", "ops": "=="}, {"input": "func([[1, 2, 6], [1, 3, 4, 5, 7, 8], [1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1,\n    4, 7, 8, 12]], 5)", "output": "[6, 5, 7, 8, 1]", "ops": "=="}], "context": "", "instance_idx": 30, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "max_Prime_Factors", "task": "MBPP", "task_id": 32, "description": "Write a python function to find the largest prime factor of a given number.", "code": "def max_Prime_Factors (n): \n    maxPrime = -1 \n    while n%2 == 0: \n        maxPrime = 2\n        n >>= 1    \n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i == 0: \n            maxPrime = i \n            n = n / i \n    if n > 2: \n        maxPrime = n  \n    return int(maxPrime)", "input_output_pairs": [{"input": "max_Prime_Factors(15)", "output": "5", "ops": "=="}, {"input": "max_Prime_Factors(6)", "output": "3", "ops": "=="}, {"input": "max_Prime_Factors(2)", "output": "2", "ops": "=="}], "context": "import math", "instance_idx": 31, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "decimal_To_Binary", "task": "MBPP", "task_id": 33, "description": "Write a python function to convert a decimal number to binary number.", "code": "def decimal_To_Binary(N): \n    B_Number = 0\n    cnt = 0\n    while (N != 0): \n        rem = N % 2\n        c = pow(10,cnt)  \n        B_Number += rem*c  \n        N //= 2 \n        cnt += 1\n    return B_Number", "input_output_pairs": [{"input": "decimal_To_Binary(10)", "output": "1010", "ops": "=="}, {"input": "decimal_To_Binary(1)", "output": "1", "ops": "=="}, {"input": "decimal_To_Binary(20)", "output": "10100", "ops": "=="}, {"input": "decimal_To_Binary(1.10)", "output": "1.1", "ops": "=="}, {"input": "decimal_To_Binary(True)", "output": "1", "ops": "=="}, {"input": "decimal_To_Binary(1000000)", "output": "11110100001001000000", "ops": "=="}, {"input": "decimal_To_Binary(25)", "output": "11001", "ops": "=="}, {"input": "decimal_To_Binary(0.00)", "output": "0", "ops": "=="}], "context": "", "instance_idx": 32, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_missing", "task": "MBPP", "task_id": 34, "description": "Write a python function to find the missing number in a sorted array.", "code": "def find_missing(ar,N): \n    l = 0\n    r = N - 1\n    while (l <= r):  \n        mid = (l + r) / 2\n        mid= int (mid) \n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \n            return (mid + 1)  \n        elif (ar[mid] != mid + 1): \n            r = mid - 1 \n        else: \n            l = mid + 1\n    return (-1)", "input_output_pairs": [{"input": "find_missing([1, 2, 3, 5], 4)", "output": "4", "ops": "=="}, {"input": "find_missing([1, 3, 4, 5], 4)", "output": "2", "ops": "=="}, {"input": "find_missing([1, 2, 3, 5, 6, 7], 5)", "output": "4", "ops": "=="}, {"input": "find_missing([1, 2, 3, 4], 3)", "output": "-1", "ops": "=="}], "context": "", "instance_idx": 33, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_rect_num", "task": "MBPP", "task_id": 35, "description": "Write a function to find the n-th rectangular number.", "code": "def find_rect_num(n):\n  return n*(n + 1)", "input_output_pairs": [{"input": "find_rect_num(4)", "output": "20", "ops": "=="}, {"input": "find_rect_num(5)", "output": "30", "ops": "=="}, {"input": "find_rect_num(6)", "output": "42", "ops": "=="}, {"input": "find_rect_num(7)", "output": "56", "ops": "=="}, {"input": "find_rect_num(1)", "output": "2", "ops": "=="}, {"input": "find_rect_num(14)", "output": "210", "ops": "=="}, {"input": "find_rect_num(12)", "output": "156", "ops": "=="}, {"input": "find_rect_num(7)", "output": "56", "ops": "=="}, {"input": "find_rect_num(8)", "output": "72", "ops": "=="}, {"input": "find_rect_num(9)", "output": "90", "ops": "=="}, {"input": "find_rect_num(10)", "output": "110", "ops": "=="}, {"input": "find_rect_num(11)", "output": "132", "ops": "=="}, {"input": "find_rect_num(12)", "output": "156", "ops": "=="}, {"input": "find_rect_num(13)", "output": "182", "ops": "=="}, {"input": "find_rect_num(11)", "output": "132", "ops": "=="}, {"input": "find_rect_num(12)", "output": "156", "ops": "=="}, {"input": "find_rect_num(7)", "output": "56", "ops": "=="}, {"input": "find_rect_num(8)", "output": "72", "ops": "=="}, {"input": "find_rect_num(9)", "output": "90", "ops": "=="}, {"input": "find_rect_num(10)", "output": "110", "ops": "=="}, {"input": "find_rect_num(11)", "output": "132", "ops": "=="}, {"input": "find_rect_num(12)", "output": "156", "ops": "=="}, {"input": "find_rect_num(13)", "output": "182", "ops": "=="}, {"input": "find_rect_num(14)", "output": "210", "ops": "=="}, {"input": "find_rect_num(15)", "output": "240", "ops": "=="}, {"input": "find_rect_num(16)", "output": "272", "ops": "=="}, {"input": "find_rect_num(17)", "output": "306", "ops": "=="}, {"input": "find_rect_num(18)", "output": "342", "ops": "=="}, {"input": "find_rect_num(19)", "output": "380", "ops": "=="}, {"input": "find_rect_num(20)", "output": "420", "ops": "=="}, {"input": "find_rect_num(21)", "output": "462", "ops": "=="}], "context": "", "instance_idx": 34, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_Nth_Digit", "task": "MBPP", "task_id": 36, "description": "Write a python function to find the nth digit in the proper fraction of two given numbers.", "code": "def find_Nth_Digit(p,q,N) :  \n    while (N > 0) : \n        N -= 1;  \n        p *= 10;  \n        res = p // q;  \n        p %= q;  \n    return res;", "input_output_pairs": [{"input": "find_Nth_Digit(1, 2, 1)", "output": "5", "ops": "=="}, {"input": "find_Nth_Digit(3, 5, 1)", "output": "6", "ops": "=="}, {"input": "find_Nth_Digit(5, 6, 5)", "output": "3", "ops": "=="}, {"input": "find_Nth_Digit(7, 8, 6)", "output": "0", "ops": "=="}, {"input": "find_Nth_Digit(4, 1, 6)", "output": "0", "ops": "=="}, {"input": "find_Nth_Digit(4, 2, 1)", "output": "20", "ops": "=="}, {"input": "find_Nth_Digit(7, 8, 5)", "output": "0", "ops": "=="}, {"input": "find_Nth_Digit(9, 7, 1)", "output": "12", "ops": "=="}, {"input": "find_Nth_Digit(3, 4, 5)", "output": "0", "ops": "=="}, {"input": "find_Nth_Digit(7, 8, 10)", "output": "0", "ops": "=="}, {"input": "find_Nth_Digit(9, 11, 9)", "output": "8", "ops": "=="}], "context": "", "instance_idx": 35, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "sort_mixed_list", "task": "MBPP", "task_id": 37, "description": "Write a function to sort a given mixed list of integers and strings.", "code": "def sort_mixed_list(mixed_list):\n    int_part = sorted([i for i in mixed_list if type(i) is int])\n    str_part = sorted([i for i in mixed_list if type(i) is str])\n    return int_part + str_part", "input_output_pairs": [{"input": "sort_mixed_list([3, 'r', 4, 'g', 'b', 2, 'w', 'g', 1])", "output": "[1, 2, 3, 4, 'b', 'g', 'g', 'r', 'w']", "ops": "=="}, {"input": "sort_mixed_list([1, 'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19, 'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([1,'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19,'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green']", "output": "([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], ['blue', 'white', 'white', 'green'])", "ops": "=="}, {"input": "sort_mixed_list([1,'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19,'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list(range(4))", "output": "[0, 1, 2, 3]", "ops": "=="}, {"input": "sort_mixed_list([-4, 0, 0, 1, 3, 1, 1, 1])", "output": "[-4, 0, 0, 1, 1, 1, 1, 3]", "ops": "=="}, {"input": "sort_mixed_list([1,'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19,'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list(set([10, 20]))", "output": "[10, 20]", "ops": "=="}, {"input": "sort_mixed_list([1,'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19,'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([1,'red', 'green', 4, 2, 'green', 'blue', 3, 'white'])", "output": "[1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}, {"input": "sort_mixed_list([19,'red', 12, 'green', 'blue', 10, 'white', 'green', 1])", "output": "[1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "ops": "=="}], "context": "", "instance_idx": 36, "test_negations": ["sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [1, 2, 3, 4, 'b', 'g', 'g', 'r', 'w']", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [1, 2, 3, 4, 'blue', 'green', 'green', 'red', 'white']", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [1, 10, 12, 19, 'blue', 'green', 'green', 'red', 'white']", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] ([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19], ['blue', 'white', 'white', 'green'])", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [0, 1, 2, 3]", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [-4, 0, 0, 1, 1, 1, 1, 3]", "sort_mixed_list(list(range(20))), ['blue', 'white', 'white', 'green'] [10, 20]"], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "div_even_odd", "task": "MBPP", "task_id": 38, "description": "Write a function to find the division of first even and odd number of a given list.", "code": "def div_even_odd(list1):\n    first_even = next((el for el in list1 if el%2==0),-1)\n    first_odd = next((el for el in list1 if el%2!=0),-1)\n    return (first_even/first_odd)", "input_output_pairs": [{"input": "div_even_odd([1, 3, 5, 7, 4, 1, 6, 8])", "output": "4", "ops": "=="}, {"input": "div_even_odd([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])", "output": "2", "ops": "=="}, {"input": "div_even_odd([1, 5, 7, 9, 10])", "output": "10", "ops": "=="}, {"input": "div_even_odd(range(16))", "output": "0.0", "ops": "=="}, {"input": "div_even_odd([1, 5, 7, 9])", "output": "-1.0", "ops": "=="}], "context": "", "instance_idx": 37, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "rearange_string", "task": "MBPP", "task_id": 39, "description": "Write a function to check if the letters of a given string can be rearranged so that two characters that are adjacent to each other are different.", "code": "def rearange_string(S):\n    ctr = Counter(S)\n    heap = [(-value, key) for key, value in ctr.items()]\n    heapq.heapify(heap)\n    if (-heap[0][0]) * 2 > len(S) + 1: \n        return \"\"\n    ans = []\n    while len(heap) >= 2:\n        nct1, char1 = heapq.heappop(heap)\n        nct2, char2 = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "input_output_pairs": [{"input": "rearange_string('aab')", "output": "'aba'", "ops": "=="}, {"input": "rearange_string('aabb')", "output": "'abab'", "ops": "=="}, {"input": "rearange_string('abccdd')", "output": "'cdabcd'", "ops": "=="}], "context": "import heapq\nfrom collections import Counter", "instance_idx": 38, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "freq_element", "task": "MBPP", "task_id": 40, "description": "Write a function to find frequency of the elements in a given list of lists using collections module.", "code": "def freq_element(nums):\n  result = Counter(chain.from_iterable(nums))\n  return result", "input_output_pairs": [{"input": "freq_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]])", "output": "{2: 3, 1: 2, 5: 2, 3: 1, 4: 1, 6: 1, 7: 1, 9: 1}", "ops": "=="}, {"input": "freq_element([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])", "output": "{1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1, 8: 1, 9: 1, 10: 1, 11: 1, 12: 1}", "ops": "=="}, {"input": "freq_element([[15, 20, 30, 40], [80, 90, 100, 110], [30, 30, 80, 90]])", "output": "{30: 3, 80: 2, 90: 2, 15: 1, 20: 1, 40: 1, 100: 1, 110: 1}", "ops": "=="}], "context": "from collections import Counter\nfrom itertools import chain", "instance_idx": 39, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "filter_evennumbers", "task": "MBPP", "task_id": 41, "description": "Write a function to filter even numbers using lambda function.", "code": "def filter_evennumbers(nums):\n even_nums = list(filter(lambda x: x%2 == 0, nums))\n return even_nums", "input_output_pairs": [{"input": "filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])", "output": "[2, 4, 6, 8, 10]", "ops": "=="}, {"input": "filter_evennumbers([10, 20, 45, 67, 84, 93])", "output": "[10, 20, 84]", "ops": "=="}, {"input": "filter_evennumbers([5, 7, 9, 8, 6, 4, 3])", "output": "[8, 6, 4]", "ops": "=="}, {"input": "filter_evennumbers([-99, 101])", "output": "[]", "ops": "=="}, {"input": "filter_evennumbers(range(10))", "output": "[0, 2, 4, 6, 8]", "ops": "=="}, {"input": "filter_evennumbers(range(10))", "output": "[0, 2, 4, 6, 8]", "ops": "=="}, {"input": "filter_evennumbers(range(2, 4))", "output": "[2]", "ops": "=="}, {"input": "filter_evennumbers(range(20))", "output": "[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]", "ops": "=="}, {"input": "filter_evennumbers(range(7, 8))", "output": "[]", "ops": "=="}, {"input": "filter_evennumbers(range(99, -1))", "output": "[]", "ops": "=="}, {"input": "filter_evennumbers(set([]))", "output": "[]", "ops": "=="}, {"input": "filter_evennumbers(set([0]))", "output": "[0]", "ops": "=="}], "context": "", "instance_idx": 40, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "find_Sum", "task": "MBPP", "task_id": 42, "description": "Write a python function to find the sum of repeated elements in a given array.", "code": "def find_Sum(arr,n): \n    return sum([x for x in arr if arr.count(x) > 1])", "input_output_pairs": [{"input": "find_Sum([1, 2, 3, 1, 1, 4, 5, 6], 8)", "output": "3", "ops": "=="}, {"input": "find_Sum([1, 2, 3, 1, 1], 5)", "output": "3", "ops": "=="}, {"input": "find_Sum([1, 1, 2], 3)", "output": "2", "ops": "=="}, {"input": "find_Sum([1, 1, 2, 3, 4, 5, 6, 3, 5], 9)", "output": "18", "ops": "=="}, {"input": "find_Sum(range(9), 12)", "output": "0", "ops": "=="}], "context": "", "instance_idx": 41, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "text_match", "task": "MBPP", "task_id": 43, "description": "Write a function to find sequences of lowercase letters joined with an underscore using regex.", "code": "def text_match(text):\n  patterns = '^[a-z]+_[a-z]+$'\n  if re.search(patterns,  text):\n    return ('Found a match!')\n  else:\n    return ('Not matched!')", "input_output_pairs": [{"input": "text_match('aab_cbbbc')", "output": "'Found a match!'", "ops": "=="}, {"input": "text_match('aab_Abbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('Aaab_abbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('aab-cbbbc')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match(u'(aeab-abcd-b)aa')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('eab-Eeab-Aac')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('eAb_e')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('eBABA')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('ab-EBab-Aba')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('ABABE')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match('^-ab-')", "output": "'Not matched!'", "ops": "=="}], "context": "import re", "instance_idx": 42, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "text_match_string", "task": "MBPP", "task_id": 44, "description": "Write a function that matches a word at the beginning of a string.", "code": "def text_match_string(text):\n        patterns = '^\\w+'\n        if re.search(patterns,  text):\n                return 'Found a match!'\n        else:\n                return 'Not matched!'", "input_output_pairs": [{"input": "text_match_string(' python')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('python')", "output": "'Found a match!'", "ops": "=="}, {"input": "text_match_string('  lang')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('foo')", "output": "'Found a match!'", "ops": "=="}, {"input": "text_match_string('    This & <is> a test & test')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('<code>')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('<source>')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('<start>')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('<end>')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('1')", "output": "'Found a match!'", "ops": "=="}, {"input": "text_match_string('\\0 \\t, 1\\n-?\\0')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string('')", "output": "'Not matched!'", "ops": "=="}, {"input": "text_match_string(r'\\textbf{\\r\\n}')  # Python regular expressions", "output": "'Not matched!'", "ops": "=="}], "context": "import re", "instance_idx": 43, "test_negations": [], "exclude_tests": ["text_match_string(r'\\textbf{\\r\\n}')  # Python regular expressions 'Not matched!'", "text_match_string(r'\\textbf{\\r\\n}')  # Python regular expressions 'Found a match!'"]}
{"source_file": "mbpp.jsonl", "function": "get_gcd", "task": "MBPP", "task_id": 45, "description": "Write a function to find the gcd of the given array elements.", "code": "def find_gcd(x, y): \n\twhile(y): \n\t\tx, y = y, x % y \n\treturn x \ndef get_gcd(l):\n  num1 = l[0]\n  num2 = l[1]\n  gcd = find_gcd(num1, num2)\n  for i in range(2, len(l)):\n    gcd = find_gcd(gcd, l[i])\n  return gcd", "input_output_pairs": [{"input": "get_gcd([2, 4, 6, 8, 16])", "output": "2", "ops": "=="}, {"input": "get_gcd([1, 2, 3])", "output": "1", "ops": "=="}, {"input": "get_gcd([2, 4, 6, 8])", "output": "2", "ops": "=="}], "context": "", "instance_idx": 44, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "test_distinct", "task": "MBPP", "task_id": 46, "description": "Write a python function to determine whether all the numbers are different from each other are not.", "code": "def test_distinct(data):\n  if len(data) == len(set(data)):\n    return True\n  else:\n    return False;", "input_output_pairs": [{"input": "test_distinct([1, 5, 7, 9])", "output": "True", "ops": "=="}, {"input": "test_distinct([2, 4, 5, 5, 7, 9])", "output": "False", "ops": "=="}, {"input": "test_distinct([1, 2, 3])", "output": "True", "ops": "=="}, {"input": "test_distinct('aaaabbbb')", "output": "False", "ops": "=="}, {"input": "test_distinct('aaa')", "output": "False", "ops": "=="}, {"input": "test_distinct([2, 3, 4, 5, 6])", "output": "True", "ops": "=="}, {"input": "test_distinct([1, 2, 3, 4, 5])", "output": "True", "ops": "=="}, {"input": "test_distinct('aaa')", "output": "False", "ops": "=="}, {"input": "test_distinct('ab')", "output": "True", "ops": "=="}, {"input": "test_distinct(('aaa', 'bbb'))", "output": "True", "ops": "=="}, {"input": "test_distinct(('aaa', 'bbb', 'ccc'))", "output": "True", "ops": "=="}, {"input": "test_distinct(range(3))", "output": "True", "ops": "=="}, {"input": "test_distinct([2, 3, 4, 5])", "output": "True", "ops": "=="}, {"input": "test_distinct(list())", "output": "True", "ops": "=="}, {"input": "test_distinct((1,2,3,))", "output": "True", "ops": "=="}, {"input": "test_distinct((1,))", "output": "True", "ops": "=="}, {"input": "test_distinct(range(3))", "output": "True", "ops": "=="}, {"input": "test_distinct([2,3,4])", "output": "True", "ops": "=="}, {"input": "test_distinct((0, 0, 0,))", "output": "False", "ops": "=="}, {"input": "test_distinct(('0', '1', '', '1'))", "output": "False", "ops": "=="}, {"input": "test_distinct([4])", "output": "True", "ops": "=="}], "context": "", "instance_idx": 45, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "compute_Last_Digit", "task": "MBPP", "task_id": 47, "description": "Write a python function to find the last digit when factorial of a divides factorial of b.", "code": "def compute_Last_Digit(A,B): \n    variable = 1\n    if (A == B): \n        return 1\n    elif ((B - A) >= 5):  \n        return 0\n    else:   \n        for i in range(A + 1,B + 1): \n            variable = (variable * (i % 10)) % 10\n        return variable % 10", "input_output_pairs": [{"input": "compute_Last_Digit(2, 4)", "output": "2", "ops": "=="}, {"input": "compute_Last_Digit(6, 8)", "output": "6", "ops": "=="}, {"input": "compute_Last_Digit(1, 2)", "output": "2", "ops": "=="}, {"input": "compute_Last_Digit(3, 7)", "output": "0", "ops": "=="}, {"input": "compute_Last_Digit(20, 23)", "output": "6", "ops": "=="}, {"input": "compute_Last_Digit(1021, 1024)", "output": "4", "ops": "=="}, {"input": "compute_Last_Digit(1300, 4096)", "output": "0", "ops": "=="}, {"input": "compute_Last_Digit(2147483647, 4097152)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(7200, 650)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(100000000001, 2)", "output": "1", "ops": "=="}, {"input": "print(compute_Last_Digit(100000000001, 5))", "output": "None", "ops": "=="}, {"input": "print(compute_Last_Digit(100, 10))", "output": "None", "ops": "=="}, {"input": "print(compute_Last_Digit(50251250000001, 5))", "output": "None", "ops": "=="}, {"input": "print(compute_Last_Digit(11000080000030, 2))", "output": "None", "ops": "=="}, {"input": "compute_Last_Digit(2**16 - 1, 2**8 - 1)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(1080, 675)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(10011, 854)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(1921, 1080)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(1939, 9985)", "output": "0", "ops": "=="}, {"input": "compute_Last_Digit(1110, 31116)", "output": "0", "ops": "=="}, {"input": "compute_Last_Digit(2212, 1918)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(2228, 1998)", "output": "1", "ops": "=="}, {"input": "compute_Last_Digit(1647, 97601)", "output": "0", "ops": "=="}], "context": "", "instance_idx": 46, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "odd_bit_set_number", "task": "MBPP", "task_id": 48, "description": "Write a python function to set all odd bits of a given number.", "code": "def odd_bit_set_number(n):\n    count = 0;res = 0;temp = n\n    while temp > 0:\n        if count % 2 == 0:\n            res |= (1 << count)\n        count += 1\n        temp >>= 1\n    return (n | res)", "input_output_pairs": [{"input": "odd_bit_set_number(10)", "output": "15", "ops": "=="}, {"input": "odd_bit_set_number(20)", "output": "21", "ops": "=="}, {"input": "odd_bit_set_number(30)", "output": "31", "ops": "=="}, {"input": "odd_bit_set_number(40)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(60)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(65)", "output": "85", "ops": "=="}, {"input": "odd_bit_set_number(75)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(80)", "output": "85", "ops": "=="}, {"input": "odd_bit_set_number(90)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(95)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(100)", "output": "117", "ops": "=="}, {"input": "odd_bit_set_number(31)", "output": "31", "ops": "=="}, {"input": "odd_bit_set_number(32)", "output": "53", "ops": "=="}, {"input": "odd_bit_set_number(33)", "output": "53", "ops": "=="}, {"input": "odd_bit_set_number(34)", "output": "55", "ops": "=="}, {"input": "odd_bit_set_number(35)", "output": "55", "ops": "=="}, {"input": "odd_bit_set_number(37)", "output": "53", "ops": "=="}, {"input": "odd_bit_set_number(40)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(50)", "output": "55", "ops": "=="}, {"input": "odd_bit_set_number(60)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(60)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(90)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(90)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(40)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(50)", "output": "55", "ops": "=="}, {"input": "odd_bit_set_number(1000)", "output": "1021", "ops": "=="}, {"input": "odd_bit_set_number(40)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(60)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(61)", "output": "61", "ops": "=="}, {"input": "odd_bit_set_number(63)", "output": "63", "ops": "=="}, {"input": "odd_bit_set_number(70)", "output": "87", "ops": "=="}, {"input": "odd_bit_set_number(71)", "output": "87", "ops": "=="}, {"input": "odd_bit_set_number(74)", "output": "95", "ops": "=="}, {"input": "odd_bit_set_number(80)", "output": "85", "ops": "=="}, {"input": "odd_bit_set_number(85)", "output": "85", "ops": "=="}, {"input": "odd_bit_set_number(72)", "output": "93", "ops": "=="}], "context": "", "instance_idx": 47, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "specified_element", "task": "MBPP", "task_id": 49, "description": "Write a function to extract every first or specified element from a given two-dimensional list.", "code": "def specified_element(nums, N):\n    result = [i[N] for i in nums]\n    return result", "input_output_pairs": [{"input": "specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 0)", "output": "[1, 4, 7]", "ops": "=="}, {"input": "specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 2)", "output": "[3, 6, 9]", "ops": "=="}, {"input": "specified_element([[1, 2, 3, 2], [4, 5, 6, 2], [7, 1, 9, 5]], 1)", "output": "[2, 5, 1]", "ops": "=="}], "context": "", "instance_idx": 48, "test_negations": [], "exclude_tests": []}
{"source_file": "mbpp.jsonl", "function": "min_length_list", "task": "MBPP", "task_id": 50, "description": "Write a function to find the list with minimum length using lambda function.", "code": "def min_length_list(input_list):\n    min_length = min(len(x) for x in input_list )  \n    min_list = min(input_list, key = lambda i: len(i))\n    return(min_length, min_list)", "input_output_pairs": [{"input": "min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])", "output": "(1, [0])", "ops": "=="}, {"input": "min_length_list([[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]])", "output": "(1, [1])", "ops": "=="}, {"input": "min_length_list([[3, 4, 5], [6, 7, 8, 9], [10, 11, 12], [1, 2]])", "output": "(2, [1, 2])", "ops": "=="}, {"input": "min_length_list([[0], [1], [1]])", "output": "(1, [0])", "ops": "=="}], "context": "", "instance_idx": 49, "test_negations": [], "exclude_tests": []}
